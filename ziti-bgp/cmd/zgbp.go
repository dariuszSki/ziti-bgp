package cmd

import (
	"context"
	"github.com/coreos/go-iptables/iptables"
	gobgpApi "github.com/osrg/gobgp/v3/api"
	"github.com/spf13/cobra"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	apb "google.golang.org/protobuf/types/known/anypb"
	"io"
	"net"
	"os"
	"strconv"
	"strings"
	"time"
)

const (
	mangleTable = "mangle"
	srcChain    = "PREROUTING"
	dstChain    = "NF-INTERCEPT"
)

type contextLogData struct {
	topic string
	value error
}

type optsGobgpd struct {
	ConfigFile      string
	ConfigType      string
	LogLevel        string
	GrpcHosts       string
	GracefulRestart bool
	UseSdNotify     bool
}

func readIptablesChain(ipt *iptables.IPTables, table, srcChain, dstChain string) []string {
	logger.Debugf("checking iptables '%v' link '%v' --> '%v'", table, srcChain, dstChain)

	ruleList, err := ipt.List(table, dstChain)
	if err != nil {
		logger.WithError(err).Error("failed to unlink chain")
	}
	return ruleList
}

func contains(a []string, x string) bool {
	for _, n := range a {
		if x == n {
			return true
		}
	}
	return false
}

func getAsn(path string) string {
	pathList := strings.Fields(path)
	for _, pathElement := range pathList {
		if strings.Split(pathElement, ":")[0] == "local_identifier" {
			logger.Debugf(strings.Split(pathElement, ":")[1])
		}
		if strings.Split(pathElement, ":")[0] == "asn" || strings.Split(pathElement, ":")[0] == "source_asn" {
			return strings.Split(pathElement, ":")[1]
		}
	}
	return ""
}

func getRoutes(pl chan []string, dbscantime *int) {

	for {
		deadline := time.Now().Add(1000 * time.Millisecond)

		ipt, err := iptables.New()
		if err != nil {
			logger.Infof("Failed to initialize iptables handle")
		}
		rules := readIptablesChain(ipt, mangleTable, srcChain, dstChain)
		gobgpList := []string{}
		keys := make(map[string]bool)
		for _, rule := range rules {
			splitString := strings.Fields(rule)
			var cidrString string
			for _, value := range splitString {
				_, cidr, err := net.ParseCIDR(value)
				if err == nil {
					cidrString = cidr.String()
				}
			}
			/* Eliminate duplicates */
			if _, subValue := keys[cidrString]; !subValue {
				keys[cidrString] = true
				if len(cidrString) != 0 {
					gobgpList = append(gobgpList, cidrString)
				}
			}
		}

		pl <- gobgpList
		logger.WithFields(map[string]interface{}{"function": "getRoutes"}).Debugf("routes to advertise %v", gobgpList)

		deadline2 := time.Now().Add(1000 * time.Millisecond)
		logger.Infof("get routes: duration %v", deadline2.Sub(deadline))

		logger.WithFields(map[string]interface{}{"function": "getRoutes"}).Warnf("sleeping for %d s before looping again", *dbscantime)
		time.Sleep(time.Duration(*dbscantime) * time.Second)

	}

}

func init() {
	rootCmd.AddCommand(clientCmd)
	clientCmd.AddCommand(serverCmd)
	serverCmd.Flags().StringP("config-file", "c", "", "specifying a config file")
	serverCmd.Flags().StringP("config-type", "t", "toml", "specifying config type (toml, yaml, json)")
	serverCmd.Flags().StringP("api-hosts", "a", ":50051", "specify the hosts that gobgpd listens on")
	serverCmd.Flags().BoolP("graceful-restart", "r", true, "flag restart-state in graceful-restart capability")
	serverCmd.Flags().BoolP("sdnotify", "n", true, "use sd_notify protocol")
}

var (
	clientCmd = &cobra.Command{
		Use:   "client",
		Short: "zbgp client command",
		Long: `This command runs zbgp in client mode which will look up the iptables chain named NF-INTERCEPTS
and update the gobgp server with the routes generated by the ziti services`,
		PreRun: zlogs,
		Run:    zgbp,
	}
	serverCmd = &cobra.Command{
		Use:    "server",
		Short:  "gobgp server command",
		Long:   `This command runs gobgp in server mode that the client can use a a bgp speaker to neighbors`,
		PreRun: zlogs,
		Run:    zgbp,
	}
)

func zgbp(cmd *cobra.Command, args []string) {

	cflag, _ := cmd.Flags().GetString("config-file")
	tflag, _ := cmd.Flags().GetString("config-type")
	aflag, _ := cmd.Flags().GetString("api-hosts")
	rflag, _ := cmd.Flags().GetBool("graceful-restart")
	nflag, _ := cmd.Flags().GetBool("sdnotify")

	var opts optsGobgpd
	opts.ConfigFile = cflag
	opts.ConfigType = tflag
	opts.GrpcHosts = aflag
	opts.GracefulRestart = rflag
	opts.UseSdNotify = nflag

	if opts.ConfigFile != "" {
		go func() {
			zgbpd(opts)
		}()
		time.Sleep(15 * time.Second)
	}
	conn, err := grpc.DialContext(context.TODO(), ":50051", grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		logger.WithError(err).Error("fail to connect to gobgp")
	}
	defer func(conn *grpc.ClientConn) {
		err := conn.Close()
		if err != nil {
			logger.WithError(err).Error("Check the gobgp api server")
		}
	}(conn)

	//client channel to gobgp api server
	client := gobgpApi.NewGobgpApiClient(conn)

	/* requesting bgp global config */
	bgpConfig, err := client.GetBgp(context.Background(), &gobgpApi.GetBgpRequest{})
	if err != nil {
		logger.WithError(err).Error("fail to get gobgp info with error")
		os.Exit(1)
	}
	logger.Data(&contextLogData{"Config", nil}).Debug(bgpConfig.Global.String())
	asnLocal := getAsn(bgpConfig.Global.String())
	logger.Info(asnLocal)

	/* announce or withdraw routes */
	dbscantime := 30
	pl := make(chan []string)

	go getRoutes(pl, &dbscantime)
	a1, _ := apb.New(&gobgpApi.OriginAttribute{
		Origin: 0,
	})
	a2, _ := apb.New(&gobgpApi.NextHopAttribute{
		NextHop: "0.0.0.0",
	})
	a3, _ := apb.New(&gobgpApi.AsPathAttribute{
		Segments: []*gobgpApi.AsSegment{
			{
				Type:    2,
				Numbers: []uint32{},
			},
		},
	})
	attrs := []*apb.Any{a1, a2, a3}

	/* main for loop */

	for {

		newPrefixList := <-pl

		var listReader gobgpApi.GobgpApi_ListPathClient
		var listRequest = gobgpApi.ListPathRequest{
			TableType:      gobgpApi.TableType_LOCAL,
			Family:         &gobgpApi.Family{Afi: gobgpApi.Family_AFI_IP, Safi: gobgpApi.Family_SAFI_UNICAST},
			EnableFiltered: true,
		}

		deadline := time.Now().Add(1000 * time.Millisecond)
		ctx, cancel := context.WithDeadline(context.Background(), deadline)
		defer cancel()

		listReader, err = client.ListPath(ctx, &listRequest)
		if err != nil {
			logger.WithError(err).Error(`could not request the route list client stream `)
		}

		currentPrefixList := []string{}
		for {
			/* Read the gobgp global route table and build a list */
			path, err := listReader.Recv()

			if err == io.EOF {
				break
			}
			if err != nil {
				logger.WithError(err).Error("errored reading the route table")
			}

			/* Find out if prefix is local or remote */
			var prefixElements string
			prefixElements = path.Destination.String()
			asn := getAsn(prefixElements)
			logger.Debug(prefixElements)
			if asn == asnLocal || asn == "" {
				currentPrefixList = append(currentPrefixList, path.Destination.GetPrefix())
			}
		}

		logger.Debugf("current local route list: %v", currentPrefixList)
		logger.Debugf("proposed local route list: %v", newPrefixList)

		/* Add new prefixes if any */
		for _, prefix := range newPrefixList {
			if contains(currentPrefixList, prefix) == false {
				logger.Debugf("prefix: %v will be added", prefix)
				prefixSplit := strings.Split(prefix, "/")
				prefixlen, _ := strconv.Atoi(prefixSplit[1])
				nlri, _ := apb.New(&gobgpApi.IPAddressPrefix{
					Prefix:    prefixSplit[0],
					PrefixLen: uint32(prefixlen),
				})

				_, err := client.AddPath(context.Background(), &gobgpApi.AddPathRequest{
					Path: &gobgpApi.Path{
						Family: &gobgpApi.Family{Afi: gobgpApi.Family_AFI_IP, Safi: gobgpApi.Family_SAFI_UNICAST},
						Nlri:   nlri,
						Pattrs: attrs,
					},
				})
				if err != nil {
					logger.WithError(err).Error("failed to add route path")
				}
			}
		}

		/* Delete new prefixes if any */
		for _, prefix := range currentPrefixList {
			if contains(newPrefixList, prefix) == false {
				logger.Debugf("prefix: %v will be deleted", prefix)
				prefixSplit := strings.Split(prefix, "/")
				prefixlen, _ := strconv.Atoi(prefixSplit[1])
				nlri, _ := apb.New(&gobgpApi.IPAddressPrefix{
					Prefix:    prefixSplit[0],
					PrefixLen: uint32(prefixlen),
				})
				_, err = client.DeletePath(context.Background(), &gobgpApi.DeletePathRequest{
					Path: &gobgpApi.Path{
						Family: &gobgpApi.Family{Afi: gobgpApi.Family_AFI_IP, Safi: gobgpApi.Family_SAFI_UNICAST},
						Nlri:   nlri,
						Pattrs: attrs,
					},
				})
				if err != nil {
					logger.WithError(err).Error("failed to delete route path")
				}
			}
		}

		deadline2 := time.Now().Add(1000 * time.Millisecond)
		logger.Infof("update global table: duration %v", deadline2.Sub(deadline))
	}

}
